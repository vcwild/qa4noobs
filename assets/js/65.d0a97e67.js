(window.webpackJsonp=window.webpackJsonp||[]).push([[65],{356:function(e,t,i){"use strict";i.r(t);var s=i(13),a=Object(s.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"functional-testing-techniques"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#functional-testing-techniques"}},[e._v("#")]),e._v(" Functional Testing Techniques")]),e._v(" "),t("p",[e._v("Functional testing is a type of testing that validates the system against specifications and acceptance criteria. The purpose of this type of testing is to test each function of the software by providing appropriate input and verifying the output according to the functional requirements.")]),e._v(" "),t("p",[e._v("Let's explore some of the key functional testing techniques.")]),e._v(" "),t("h2",{attrs:{id:"equivalence-partitioning-bva"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#equivalence-partitioning-bva"}},[e._v("#")]),e._v(" Equivalence Partitioning (BVA)")]),e._v(" "),t("p",[e._v("Equivalence partitioning is a testing technique based on requirements in the documentation.")]),e._v(" "),t("p",[e._v("Executed through the black-box approach, it provides the tester with a clear understanding of test coverage based on requirements and specifications.")]),e._v(" "),t("p",[e._v("It does not require knowledge of internal paths, structure, and implementation of the software under test and reduces the number of test cases to a manageable level. It is intuitively used by most testers.")]),e._v(" "),t("p",[e._v("Partitioning divides user inputs into partitions or classes of equivalence, and then subdivides them into ranges of possible values, so that one of these values is elected as the basis for the tests. There are partitions for:")]),e._v(" "),t("ul",[t("li",[e._v("Valid values, which should be accepted by the system.")]),e._v(" "),t("li",[e._v("Invalid values, which should be rejected by the system.")])]),e._v(" "),t("p",[e._v("Consider a human resources system in a company that processes employee requests based on age. We have a business rule related to age stating that individuals under 16 years old cannot work, individuals between 16-60 years old are eligible for hire, and those who are 60 years old or older are not suitable for the job.")]),e._v(" "),t("p",[e._v("Dividing these rules, we have:")]),e._v(" "),t("ul",[t("li",[e._v("Invalid partition: 0-15")]),e._v(" "),t("li",[e._v("Valid partition: 16-60")]),e._v(" "),t("li",[e._v("Invalid partition: 60-")])]),e._v(" "),t("p",[e._v("Equivalence partitioning guides us to choose a subset of tests that will find more defects than a randomly chosen set.")]),e._v(" "),t("p",[e._v("When working with partitions, we observe a maxim that states:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('"Any value within a partition is as good as any other."\n')])])]),t("p",[e._v("Therefore, values belonging to the same partition must be treated equally by the system, meaning they will produce the same result. Thus, any value within the equivalence class, in terms of testing, is equivalent to any other.")]),e._v(" "),t("p",[e._v("To achieve satisfactory test coverage when implementing this technique, test cases must cover all existing partitions. In the example under analysis, we have identified 3 partitions.")]),e._v(" "),t("p",[e._v("A test script for age validation in the hiring module would have 3 test cases:")]),e._v(" "),t("p",[e._v("C1: Age = 5")]),e._v(" "),t("p",[e._v('According to the rule, it should not work; the expected value is "Should not hire."')]),e._v(" "),t("p",[e._v("C2: Age = 33")]),e._v(" "),t("p",[e._v('According to the rule, it can work; the expected value is "Can hire."')]),e._v(" "),t("p",[e._v("C3: Age = 65")]),e._v(" "),t("p",[e._v('According to the rule, it should not work; the expected value is "Should not hire."')]),e._v(" "),t("p",[e._v("It is understood that within the range of values 0-15, regardless of which one is selected within the invalid partition, it should not be accepted by the system. The same applies to the range of 16-60, multiple possibilities that result in acceptance in the system.")]),e._v(" "),t("p",[e._v("It is not necessary to test all possible values; the coverage is sufficient when choosing one within each partition.")]),e._v(" "),t("h2",{attrs:{id:"boundary-value-analysis"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#boundary-value-analysis"}},[e._v("#")]),e._v(" Boundary Value Analysis")]),e._v(" "),t("p",[e._v("It assumes that the behavior at the edge of a partition is more likely to cause errors.")]),e._v(" "),t("p",[e._v("In the example, with the boundary value technique, we would select the value 15, invalid according to the system, then we select 16, borderline, but it should yield a positive result.")]),e._v(" "),t("p",[e._v("A good practice of combining techniques is to select a random value for each partition, test it, and then validate the boundary values within each partition.")]),e._v(" "),t("ul",[t("li",[e._v("Decision Table:")])]),e._v(" "),t("p",[e._v("A relevant method for documenting business rules to be followed by the system, created from the analysis of functional specifications and identification of business rules.")]),e._v(" "),t("p",[e._v("The table contains trigger conditions, combinations of true or false for data entry, and results for each of the combinations. It is a way to express in a tabular form which set of actions should occur to arrive at an expected result.")]),e._v(" "),t("p",[e._v("The main point of the table is the business rule, which defines the set of actions to be taken based on a set of conditions.")]),e._v(" "),t("p",[e._v("In the example, if we know that from 0-15 should not work, in the table, we establish that")]),e._v(" "),t("p",[e._v("0-15 Cannot")]),e._v(" "),t("p",[e._v("16-60 Can")]),e._v(" "),t("p",[e._v("This combination can/cannot, is a visual representation to assist in documenting the rules the system follows.")]),e._v(" "),t("h2",{attrs:{id:"transition-between-states"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#transition-between-states"}},[e._v("#")]),e._v(" Transition between States")]),e._v(" "),t("p",[e._v("It is based on the idea that a system can exhibit different behaviors depending on its current state or previous events. Creating a diagram allows the test to visualize the statuses, i.e., the transitions, data entry, and events that trigger actions.")]),e._v(" "),t("p",[e._v("The technique helps identify possible invalid transactions because knowing what the system expects, when testing the combinations, we can discover faulty transactions.")]),e._v(" "),t("p",[e._v("A person can be eligible to work and then become ineligible, invalid.")]),e._v(" "),t("h3",{attrs:{id:"techniques-based-on-experience"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#techniques-based-on-experience"}},[e._v("#")]),e._v(" Techniques Based on Experience")]),e._v(" "),t("p",[e._v("These are techniques where tests are derived from the skills and experience of the tester, the individual visualization capability of the professional, based on their past work, enabling them to find errors and faults that others may not discover.")]),e._v(" "),t("p",[e._v("This topic is better explored in the article on "),t("a",{attrs:{href:"test"}},[e._v("exploratory testing")]),e._v(".")])])}),[],!1,null,null,null);t.default=a.exports}}]);